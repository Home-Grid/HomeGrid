import _map from 'lodash/fp/map';
import _values from 'lodash/values';
import _times from 'lodash/times';
import _flow from 'lodash/flow';
import _memoize from 'lodash/memoize';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

import React, { PropTypes } from 'react';

import moment from 'moment';

import { day as dayType } from './proptypes';

import CalendarDayHeaders from './day-headers';
import CalendarMonth from './month';

/**
 * Turns a moment instance into a serialized string that's unique for a month
 * and the object's locale's first day of the week. This ensures that the range
 * of months only regenerates if the locale changes, or different months are
 * passed in for the start and end dates, maximizing efficiency for re-renders.
 * @param  {moment} day
 * @return {string}
 */
var monthKey = function monthKey(day) {
  return '' + day.localeData().firstDayOfWeek() + day.format('YYYYMMZZ');
};

/**
 * Takes two inclusive endpoints and returns an array of moment objects for the
 * first of each month between those endpoints.
 * @param  {moment} firstDay
 * @param  {moment} lastDay
 * @return {Array.<moment>}
 */
var getMonthsInRange = _memoize(_flow(
// Wrap in an array to more easily have multiple values flow through these
// functions.
function (firstDay, lastDay) {
  return [firstDay, lastDay];
},

// Move both days to the start of their months so the math is more
// consistent.
_map(function (day) {
  return day.clone().startOf('month');
}),

// Actually generate the moment objects for each month.
function (_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      firstDay = _ref2[0],
      lastDay = _ref2[1];

  return _times(lastDay.diff(firstDay, 'months') + 1, function (n) {
    return firstDay.clone().add(n, 'months');
  });
}),
// memoize key function
function (firstDay, lastDay) {
  return monthKey(firstDay) + '-' + monthKey(lastDay);
});

var DayHeaderStyles = {
  AboveFirstMonth: 'above-first',
  InEveryMonth: 'in-every',
  InFirstMonth: 'in-first'
};

export default function Calendar(props) {
  var className = props.className,
      compactMonths = props.compactMonths,
      dayAbbrevs = props.dayAbbrevs,
      dayHeaderClassName = props.dayHeaderClassName,
      dayHeaderStyle = props.dayHeaderStyle,
      firstRenderedDay = props.firstRenderedDay,
      gutterWidth = props.gutterWidth,
      lastRenderedDay = props.lastRenderedDay,
      monthClassName = props.monthClassName,
      monthHeaderClassName = props.monthHeaderClassName,
      monthHeaderFormat = props.monthHeaderFormat,
      renderDay = props.renderDay,
      renderMonthHeader = props.renderMonthHeader,
      weekClassName = props.weekClassName;


  var firstDay = moment(firstRenderedDay);
  var lastDay = moment(lastRenderedDay);
  var months = compactMonths ? [firstDay] : getMonthsInRange(firstDay, lastDay);
  var firstWeekday = firstDay.localeData().firstDayOfWeek();

  return React.createElement(
    'div',
    { className: className },
    dayHeaderStyle === DayHeaderStyles.AboveFirstMonth ? React.createElement(CalendarDayHeaders, {
      className: dayHeaderClassName,
      dayAbbrevs: dayAbbrevs,
      firstWeekday: firstWeekday,
      gutterWidth: gutterWidth
    }) : null,
    months.map(function (firstOfMonth, idx) {
      return React.createElement(CalendarMonth, {
        className: monthClassName,
        dayAbbrevs: dayAbbrevs,
        dayHeaderClassName: dayHeaderClassName,
        firstDay: moment.max(firstOfMonth, firstDay),
        firstWeekday: firstWeekday,
        gutterWidth: gutterWidth,
        headerClassName: monthHeaderClassName,
        headerInsideDay: compactMonths,
        headerFormat: monthHeaderFormat,
        includeDayHeaders: dayHeaderStyle === DayHeaderStyles.InEveryMonth || dayHeaderStyle === DayHeaderStyles.InFirstMonth && idx === 0,
        key: firstOfMonth.format('YYYYMM'),
        lastDay: compactMonths ? lastDay : moment.min(firstOfMonth.clone().endOf('month'), lastDay),
        renderDay: renderDay,
        renderHeader: renderMonthHeader,
        weekClassName: weekClassName
      });
    })
  );
}

Calendar.propTypes = {
  className: PropTypes.string,
  compactMonths: PropTypes.bool.isRequired,

  // Array of 7 strings to use as column headers for days. Start with Sunday.
  dayAbbrevs: PropTypes.arrayOf(PropTypes.string).isRequired,
  dayHeaderClassName: PropTypes.string,
  dayHeaderStyle: PropTypes.oneOf(_values(DayHeaderStyles)),
  firstRenderedDay: dayType.isRequired,
  gutterWidth: PropTypes.string,
  lastRenderedDay: dayType.isRequired,
  monthClassName: PropTypes.string,
  monthHeaderClassName: PropTypes.string,
  monthHeaderFormat: PropTypes.string,

  // Function that takes a moment instance and returns a single ReactElement.
  renderDay: PropTypes.func.isRequired,
  renderMonthHeader: PropTypes.func.isRequired,
  weekClassName: PropTypes.string
};

Calendar.defaultProps = {
  compactMonths: false,
  dayAbbrevs: ['Su', 'M', 'T', 'W', 'Th', 'F', 'Sa'],
  dayHeaderStyle: DayHeaderStyles.InFirstMonth,
  monthHeaderFormat: 'MMMM YYYY',
  renderDay: function renderDay(day) {
    return React.createElement(
      'div',
      null,
      day.format('YYYY-MM-DD')
    );
  },
  renderMonthHeader: function renderMonthHeader(day, format) {
    return day.format(format);
  }
};

Calendar.DayHeaderStyles = DayHeaderStyles;