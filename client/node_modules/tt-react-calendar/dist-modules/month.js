import _head from 'lodash/fp/head';
import _sortBy from 'lodash/fp/sortBy';
import _values from 'lodash/fp/values';
import _invoke from 'lodash/fp/invoke';
import _groupBy from 'lodash/fp/groupBy';
import _map from 'lodash/map';
import _times from 'lodash/times';
import _flow from 'lodash/flow';
import _memoize from 'lodash/memoize';
import React, { PropTypes } from 'react';

import moment from 'moment';
import classNames from 'classnames';

import CalendarDayHeaders from './day-headers';

var daysInRange = _memoize(function (firstDay, lastDay) {
  var arr = [];

  // Not just the name of a Trevor Noah special...
  var dayWalker = firstDay.clone();

  while (dayWalker.isSameOrBefore(lastDay, 'day')) {
    arr.push(dayWalker.clone());
    dayWalker.add(1, 'day');
  }

  return arr;
},
// memoization key
// NOTE(Jeremy): The "e" is the locale-specific day of the week. If that
// changes, it should invalidate the cache.
function (firstDay, lastDay) {
  return firstDay.format('eYYYYMMDDZZ') + '-' + lastDay.format('eYYYYMMDDZZ');
});

/**
 * Takes an array of days, and breaks them into an array of arrays, grouped by
 * week.
 * @example
 * partitionByWeek(daysInRange(moment('2017-03-16'), moment('2017-03-27')))
 *
 * // would return (depending on the locale for momentjs)...
 * [
 *   [moment('2017-03-16'), moment('2017-03-17'), moment('2017-03-18')],
 *   [moment('2017-03-19'), moment('2017-03-21'), ...rest of the week],
 *   [moment('2017-03-26'), moment('2017-03-27')],
 * ]
 * @param  {Array.<moment>} days Array of moment day objects to partition
 * @return {Array.<Array.<moment>>}
 */
var partitionByWeek = _memoize(_flow(_groupBy(_invoke('week')), _values, _sortBy(_head)));

/**
 * Generates an array of dummy day elements to fill up space and make alignment
 * work correctly. Gutters get weird when we don't have a consistent number of
 * elements in every row, so these dummy elements help us get around that.
 * The fact that they're needed is making me wish CSS Grid Layout had better
 * support. Old iOS makes me sad.
 * @param  {number}   num                    How many dummy elements
 * @param  {string}   options.gutterWidth    CSS length
 * @param  {?boolean} options.firstHasMargin
 *   Should the first dummy element have a margin-left? Defaults to false.
 * @return {Array.<ReactElement>}
 */
var dummyDays = function dummyDays(num, _ref) {
  var gutterWidth = _ref.gutterWidth,
      _ref$firstHasMargin = _ref.firstHasMargin,
      firstHasMargin = _ref$firstHasMargin === undefined ? false : _ref$firstHasMargin;
  return _times(num, function (n) {
    return React.createElement('div', {
      key: n,
      className: 'tt-cal-dummyDay',
      style: {
        marginLeft: firstHasMargin || n !== 0 ? gutterWidth : null
      }
    });
  });
};

/* NOTE(Jeremy):
 * This is _usually_ a single month to be rendered. However, if the outer
 * calendar component has the `compactMonths` flag set, then this gets
 * `headerInsideDay`, and at that point should only be considered a collection
 * of days, not limited to a single month.
 */
export default function CalendarMonth(props) {
  var className = props.className,
      dayAbbrevs = props.dayAbbrevs,
      dayHeaderClassName = props.dayHeaderClassName,
      firstDay = props.firstDay,
      firstWeekday = props.firstWeekday,
      gutterWidth = props.gutterWidth,
      headerClassName = props.headerClassName,
      headerFormat = props.headerFormat,
      headerInsideDay = props.headerInsideDay,
      includeDayHeaders = props.includeDayHeaders,
      lastDay = props.lastDay,
      renderDay = props.renderDay,
      renderHeader = props.renderHeader,
      weekClassName = props.weekClassName;


  var dayWeeks = partitionByWeek(daysInRange(firstDay, lastDay));

  return React.createElement(
    'div',
    {
      className: classNames(className, { 'tt-cal-headerInsideDay': headerInsideDay })
    },
    headerInsideDay ? null : React.createElement(
      'h3',
      { className: headerClassName },
      renderHeader(firstDay, headerFormat)
    ),
    includeDayHeaders ? React.createElement(CalendarDayHeaders, {
      className: dayHeaderClassName,
      dayAbbrevs: dayAbbrevs,
      firstWeekday: firstWeekday,
      gutterWidth: gutterWidth
    }) : null,
    React.createElement(
      'div',
      null,
      _map(dayWeeks, function (days) {
        return React.createElement(
          'div',
          {
            key: days[0].week(),
            className: classNames('tt-cal-week', weekClassName)
          },
          days[0].isSame(firstDay) ? dummyDays(days[0].weekday(), { gutterWidth: gutterWidth }) : null,
          days.map(function (day) {
            var shouldRenderHeader = headerInsideDay && (
            // We're either the first day rendered, or
            // the first day of a new month.
            day.isSame(firstDay) || day.date() === 1);

            return React.createElement(
              'div',
              {
                key: day.format('YYYYMMDD'),
                className: 'tt-cal-day',
                style: {
                  marginLeft: day.weekday() === 0 ? null : gutterWidth
                }
              },
              shouldRenderHeader ? React.createElement(
                'h3',
                {
                  className: classNames('tt-cal-inlineMonthHeader', headerClassName)
                },
                renderHeader(day, headerFormat)
              ) : null,
              renderDay(day)
            );
          }),
          days[0].week() === lastDay.week() ? dummyDays(7 - (lastDay.weekday() + 1), {
            gutterWidth: gutterWidth,
            firstHasMargin: true
          }) : null
        );
      })
    )
  );
}

CalendarMonth.propTypes = {
  className: PropTypes.string,
  dayAbbrevs: PropTypes.arrayOf(PropTypes.string).isRequired,
  dayHeaderClassName: PropTypes.string,
  firstDay: PropTypes.instanceOf(moment).isRequired,
  firstWeekday: PropTypes.number,
  gutterWidth: PropTypes.string,
  headerClassName: PropTypes.string,
  headerFormat: PropTypes.string.isRequired,
  headerInsideDay: PropTypes.bool.isRequired,
  includeDayHeaders: PropTypes.bool.isRequired,
  lastDay: PropTypes.instanceOf(moment).isRequired,
  renderDay: PropTypes.func.isRequired,
  renderHeader: PropTypes.func.isRequired,
  weekClassName: PropTypes.string
};

CalendarMonth.defaultProps = {
  headerInsideDay: false,
  includeDayHeaders: true
};